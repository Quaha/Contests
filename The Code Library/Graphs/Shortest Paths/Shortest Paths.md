# Shortest Paths

## Алгоритм Дейкстры

Алгоритм Дейкстры находит кратчайшие пути от заданной вершины $s$ до всех остальных в графе без ребер отрицательного веса.

## Отрицательные рёбра циклы

Добавление в граф рёбер с отрицательным весом может привести к тому, что до некоторых вершин пропадут пути минимального веса, так как появятся отрицательные циклы.

Стоит заметить, что неориентированное отрицательное ребро и отрицательная петля являются отрицательными циклами.

Кратчайшего пути до некоторой вершины $u$ из некоторой вершины $v$ может не существовать по 2-м причинам:

1) Вершина $u$ не может быть достигнута из вершины $v$
2) Вершина $u$ достижима из некоторого отрицательного цикла, который достижим из вершины $v$ 

Наличие отрицательных циклов может привести к быстрому переполнению, поэтому при обновлении расстояния в алгоритмах его нужно ограничивать снизу как $-INF$, с другой стороны не всегда наличие отрицательного цикла приведёт к чрезмерному росту модуля расстояния.

### Задачи, связанные с отрицательными циклами

**Решаемые задачи:**
- Проверить наличие отрицательных циклов в графе и вывести один из них
- Найти все вершины, до которых не существует кратчайшего пути

Все решаемые задачи могут быть решены как алгоритмом Форда-Беллмана, так и алгоритмом Флойда-Уоршелла.

**Нерешаемые задачи:**
- Найти и вывести все отрицательные циклы в графе - их может быть экспоненциально много
- Найти кратчайшие *простые* пути или длинейшие *простые* пути - ***NP*** сложная задача в общем случае

## Алгоритм Форда-Беллмана

Алгоритм Форда-Беллмана находит кратчайшие пути от заданной вершины $s$ до всех остальных в графе, в котором могут быть ребра отрицательного веса.

```cpp
int n, m;

// g - adjacency lists
vector<vector<pair<int, int>>> g;

// g[Ui] = {{Vij, Wij}, ...}

```

Пусть до каждой достижимой вершины существуют кратчайшие пути. Тогда каждый кратчайший путь содержит не более $n-1$ ребра. Эти кратчайшие пути можно найти с помощью динамического программирования.

Пусть $dp[k][u]$ - минимальная длина пути из вершины $s$ в вершину $u$, содержащего ровно $k$ рёбер ($k \in \{0, ..., n - 1\}, u \in \{1, ..., n\}$).

```cpp
int dp[n][n + 1]; // O(n^2) states
```

Тогда базовыми состояними динамики будут $dp[0][s]=0$, $dp[0][u] = +INF, \forall u \ne s$.

```cpp

for (int k = 0; k < n; k++) {
    for (int u = 1; u <= n; u++) {
        dp[k][u] = INF;    
    }
}

dp[0][s] = 0;

```

Эта динамика будет иметь следующие переходы: 

$dp[k][v] = \min\limits_{(u, v) \in E} (dp[k - 1][u] + weight((u, v)))$, $\forall k > 0$, при этом переход следует делать только из тех состояний, где $dp[k-1][u] \ne +INF$.

```cpp
for (int k = 1; k < n; k++) {
    for (int u = 1; u <= n; u++) {
        for (auto [v, w]: g[u]) {
            if (dp[k - 1][u] != INF) {
                dp[k][v] = min(dp[k][v], dp[k - 1][u] + w);
            }
        }  
    }
}

// O(n*(n + m))
```

После просчёта этой динамики кратчайшее расстояния от вершины $s$ до некоторой $u$ будет равно $\min\limits_{k = 0..n-1} (dp[k][u])$.

```cpp
int dist_u = INF;

for (int k = 0; k < n; k++) {
    dist_u = min(dist_u, dp[k][u]);
}

```

Заметим, что вместо того, чтобы в конце вычислять этот минимум, можно немного изменить динамику: пусть теперь $dp[k][u]$ - минимальная длина пути из вершины $s$ в вершину $u$, содержащего не более $k$ рёбер.

В этом случае переходы примут вид: $dp[k][v] = \min(dp[k - 1][v], \min\limits_{(u, v) \in E} (dp[k - 1][u] + weight((u, v))))$, $\forall k > 0$, при этом переход следует делать только из тех состояний, где $dp[k-1][u] \ne +INF$.

```cpp
for (int k = 1; k < n; k++) {
    for (int u = 1; u <= n; u++) {
        dp[k][u] = dp[k - 1][u];
    }
    for (int u = 1; u <= n; u++) {
        for (auto [v, w]: g[u]) {
            if (dp[k - 1][u] != INF) {
                dp[k][v] = min(dp[k][v], dp[k - 1][u] + w);
            }
        }  
    }
}

// O(n*(n + m))
```

Длина кратчайшего пути до вершины $u$ в такой динамике будет храниться в состоянии $dp[n-1][u]$.

```cpp
int dist_u = dp[n-1][u];
```

Заметим, что $k$-ый слой динамики зависит только от $k-1$ слоя, поэтому вместо использования $k$ слоёв можно использовать всего 2 и их чередовать.

```cpp
int dp[2][n + 1]; // O(n) states

...

for (int k = 1; k < n; k++) {
    for (int u = 1; u <= n; u++) {
        dp[k % 2][u] = dp[(k - 1) % 2][u];
    }
    for (int u = 1; u <= n; u++) {
        for (auto [v, w]: g[u]) {
            if (dp[(k - 1) % 2][u] != INF) {
                dp[k % 2][v] = min(dp[k % 2][v], dp[(k - 1) % 2][u] + w);
            }
        }  
    }
}

// O(n*(n + m))
```

Оказывается, что динамику можно считать, используя всего один слой, при этом ответ никак не изменится.

Пусть $dp[u]$ - длина кратчайшего пути до вершины $u$. $n-1$ раз попробуем совершить следующие переходы динамики: $dp[v] = \min(dp[v], \min\limits_{(u, v) \in E} (dp[u] + weight((u, v))))$, при этом переход следует делать только из тех состояний, где $dp[u] \ne +INF$.

```cpp
int dp[n + 1]; // O(n) states

...

for (int k = 1; k < n; k++) {
    for (int u = 1; u <= n; u++) {
        for (auto [v, w]: g[u]) {
            if (dp[u] != INF) {
                dp[v] = min(dp[v], dp[u] + w);
            }
        }  
    }
}

// O(n*(n + m))
```

Заметим, что на одной итерации некоторое состояние динамики может быть обновлено из состояния, которое тоже было обновлено на этой же итерации. Это означает, что на $i$-ой итерации для некоторых вершин вместо длины кратчайшего пути, состоящего не более чем из $i$ рёбер, будет посчитана длина пути, состоящего из не более чем $i + k, k \ge 0$ рёбер. Фактически на каждой итерации $i$ для каждой вершины $u$ будет существовать некоторое $k_{iu} \ge 0$ такое, что $dp[u]$ будет хранить длину кратчайшего пути до вершины $u$, который состоит не более чем из $i + k_{iu}$ рёбер. На самом деле эти значения $k_{ui}$ нас не интересуют, ведь после $n-1$ итерации в $dp[u]$ будет храниться длина кратчайшего пути, число рёбер в котором от 0 до некоторого $j >= n - 1$, а так как длина кратчайшего пути по рёбрам не превосходит $n-1$, то в $dp[u]$ будет просто длина кратчайшего пути до вершины $u$.

Заметим, что код можно ещё сильнее упростить: два вложенных цикла фактически перебирают все рёбра графа, поэтому если задать граф списком рёбер, то код примет следующий вид:

```cpp

struct Edge { // directed edge
    int u, v, w;
};

int dp[n + 1]; // O(n) states

vector<Edge> edges;
...

for (int k = 1; k < n; k++) {
    for (auto [u, v, w]: edges) {
        if (dp[u] != INF) {
            dp[v] = min(dp[v], dp[u] + w);
        } 
    }
}

// O(n*m)
```
### Отрицательные циклы

Если в графе есть отрицательный цикл, то алгоритм будет делать обновления вдоль его вершин на каждой итерации алгоритма. Если после $n-1$ итерации запустить ещё одну, то обновление хотя бы одного расстояния будет означать наличие отрицательного цикла.

Также наличие отрицательных циклов может достаточно быстро привести к переполнению - чтобы этого избежать, следует ограничить минимальное расстояние с помощью $-INF$ снизу. Это не испортит нахождение отрицательных циклов, ведь в нём будет хотя бы одно отрицательное ребро, по которому будут происходить обновления.

### SPFA - алгоритм

SPFA (Shortest Paths Faster Algorithm) алгоритм является более быстрой по константе версией алгоритма Форда-Беллмана.

Во-первых, алгоритм останавливает работу, если на какой-либо из $n-1$ итерации не сделал ни одного обновления.

Во-вторых, не имеет смысла просматривать рёбра, исходящие из вершин, которые не были обновлены на последней итерации (можно реализовать очередь)

## Алгоритм Флойда-Уоршелла

